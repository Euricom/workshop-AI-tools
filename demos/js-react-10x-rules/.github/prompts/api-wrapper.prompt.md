# API Wrapper Pattern Rules for Data Access Layer

## Core Principles
- **Separation of Concerns**
  - Create dedicated API wrapper files per domain/resource
  - Keep API logic separate from UI components
  - Place all API wrappers in `src/api/{domain}` folders

## File Structure
- **Required Files Per Domain:**
  ```
  src/api/{domain}/
  ├── types.ts        # Type definitions
  ├── {domain}.ts     # API wrapper functions
  └── index.ts        # Public exports
  ```

## Implementation Guidelines

- **Type Definitions**
  - **Schema-First Approach**
    - Derive DTO types from OpenAPI schema
    - Define domain interfaces that transform DTOs for frontend use
    - Place types in `types.ts` file per domain

  Example:
  ```typescript
  // types.ts
  import { components } from "../schema";

  // ✅ DO: Derive DTO types from schema
  export type ProductDTO = components["schemas"]["product"];
  export type ProductListDTO = components["schemas"]["productList"];
  export type ProductCreateDTO = components["schemas"]["productCreate"];
  export type ProductUpdateDTO = components["schemas"]["productUpdate"];

  // ✅ DO: Define domain types with transformations
  export type Product = Omit<ProductDTO, "createdAt" | "updatedAt"> & {
    createdAt: Date;  // Transform from string to Date
    updatedAt: Date;
  };

  export type ProductList = Omit<ProductListDTO, "items"> & {
    items: Product[];  // Use transformed Product type
  };
  ```

- **Data Mapping**
  - Create mapper functions to transform DTOs to domain objects
  - Handle date conversions and data transformations
  ```typescript
  // ✅ DO: Create explicit mappers
  const productMapper = (dto: ProductDTO): Product => ({
    ...dto,
    createdAt: new Date(dto.createdAt)
  });
  ```

- **API Functions**
  - Use descriptive function names that match the operation
  - Accept ApiInstance as first parameter
  - Define explicit parameter interfaces for complex queries
  - Return typed promises
  ```typescript
  // ✅ DO: Clear function signatures
  export const getProducts = async (
    api: ApiInstance,
    params: GetProductsParams
  ): Promise<Product[]>
  ```

- **Error Handling**
  - Let API errors propagate to the caller
  - Use the ApiInstance for consistent error handling

- **Query Parameters**
  - Define interfaces for query parameters
  - Use optional properties for optional parameters
  ```typescript
  // ✅ DO: Define query parameter interface
  export interface GetProductsParams {
    page?: number;
    pageSize?: number;
    sortBy?: string;
    filter?: string;
  }
  ```

## Best Practices
- Keep wrapper functions simple and focused
- Use meaningful parameter and interface names
- Document complex transformations
- Follow consistent naming conventions across domains
- Use TypeScript for better type safety

## Anti-patterns
```typescript
// ❌ DON'T: Mix API logic with UI components
const ProductList = () => {
  const fetchProducts = async () => {
    const response = await fetch('/api/products');
    // ...
  }
}

// ❌ DON'T: Skip type definitions
const getProducts = async (api) => {
  const data = await api.get('/products');
  return data;
}
```

Generated by Copilot